---
layout: post
title: Higher-order partially evaluated templates (HOPE Templates)
tags:
- higher-order
- HOPE
- partial evaluation
- Scheme
- templates
- templating languages
status: draft
type: post
published: false
meta:
  blogger_blog: higher-order.blogspot.com
  blogger_author: krukowhttp://www.blogger.com/profile/02045796732071392830noreply@blogger.com
  blogger_permalink: /feeds/posts/default/3045041508832438466
---
In a previous posting I briefly introduced <a href="http://higher-order.blogspot.com/2008/04/there-is-still-hope-for-templates.html">the templating language HOPE</a>. The post was a quick scribble on an idea for a higher-order functional templating language; it didn't go into any detail or reflect much. This posting will recap the idea and further illustrate it. I'll talk briefly about a mini-implementation attempt (which unfortunately failed), and where to go from here with implementation.<br /><br /><span style="font-weight: bold;">Hope Templates - Introduction</span><br />When I write about templating languages I am speaking about languages and tools for general-purpose text generation. I'm not referring to "<a href="http://en.wikipedia.org/wiki/Template_metaprogramming">template metaprogramming</a>" which is more specific, e.g., C++ templates which is a templating mechanism designed specifically to produce C++ programs as output. When that is said, I will use examples from markup (mostly XHTML) generation as our application domain.<br /><br />In HOPE, a template can be thought of as a (higher-order) function that takes other templates as input and gives other templates as output. Strings are a special type of template (zero-order). Templates can be evaluated, and the result of such evaluation is always a string.<br /><br />In our examples, we denote template evaluation by a relation ->. For example<br /><br /><center>Example 1: zero-order template</center><br /><div style="border: 1px solid ; padding: 2px;"><span style="font-family: courier new;">Hello World!</span><br /></div><br /><br />Is a template and <span style="font-family: courier new;">Hello World!</span> -> "Hello World!" I.e. (in terms of more formal semantics) the template <span style="font-style:italic;">denoted by</span> the string on the left side evaluates to the string "Hello World!".<br /><br /><span style="font-weight:bold;">What's new?</span><br />Just about every templating language I know has the property that any string is a template, e.g., if Example 1 would be evaluated in JSP, ERB or FreeMarker, it would result in the same output. To appreciate what is new about HOPE, we need to introduce template abstraction, which one can think of as a function definition.<br /><br /><center>Example 2: template abstraction</center><br /><div style="border: 1px solid ; padding: 2px;"><span style="font-family: courier new;">&lambda;x y.Hello x and y!</span><br /></div><br />The expression in Example 2 denotes a template which has two input parameters: x and y. That template can be applied to two input templates and the result is a new template. For example, we can apply it to the templates denoted by "Olivier" and "Karl", and the result would be a (zero-order) template that evaluates to the string "Hello Olivier and Karl!". Simple stuff (if you are a functional programmer);  if not, you probably understand it immediately anyway (except perhaps for the use of &lambda; for abstraction).<br /><br />Already here we see several differences with other patterns in common templating languages. First of all, note that there is no "escape" syntax; for example, in the concrete syntax, variables 'x' and 'y' are just text, as are the strings 'Hello' and 'World'. This is (in my opinion) much more nice than e.g. Hello <%= getX() %> that one might see in JSP. This is a common theme in HOPE, which I call "flexible syntax" -- later we shall see more examples of what this means, but one example is local redefinition of concrete syntax (e.g. using \ / instead of () for template application). Now, one might have the opinion that concrete syntax really doesn't matter all that much (LISP, anyone?), but in a templating language, I really feel it makes a huge difference.<br /><br />A second difference with standard templating languages is the functional nature of templates. JSP (and the various variants ERB, ASP, etc) consider templates an alternating sequence of raw or static text to be outputted, and syntactically escaped fragments of Java (or Ruby or ??) code that denotes a computation resulting in a dynamically computed string. In contrast, HOPE does not revert back to a general purpose language for the dynamic parts, instead it uses a domain specific functional language for dynamic computations. FreeMarker and StringTemplate are languages that share this approach (StringTemplate being the only functional language that follows this approach). Both FreeMarker and StringTemplate differ from HOPE (and from each other) in some fundamental ways that could be the discussion of another blog-post.<br /><br /><span style="font-weight:bold;">Partial evaluation as application</span><br />A fundamental and (as far as I know) unique feature of HOPE is that all template application is <span style="font-style:italic;">partial</span>. If you know about partial evaluation you can think of template application as partial evaluation of a function with respect to one of its input parameters. This is probably best understood by means of an example. In the following we use the equality symbol as meaning "denotes the same template as".<br /><br /><center>Example 3: application (partial evaluation)</center><br /><div style="border: 1px solid ; padding: 2px;"><span style="font-family: courier new;">(&lambda;x y.Hello x and y!) y:Karl = &lambda;x.Hello x and Karl!</span><br/><br /><span style="font-family: courier new;">(&lambda;x y.Hello x and y!) x:Olivier = &lambda;y.Hello Olivier and y!</span><br /></div><br />The application of the left-hand-side (LHS) template with respect to 'y' bound to the value 'Karl' replaces 'y' in the inner expression with 'Karl', just as expected. <br /><br /><br /><span style="font-weight: bold;">An implementation attempt</span><br />I tried to implement a HOPE compiler in Scheme: the compiler would translate a HOPE AST to a Scheme function representing the template. The idea was to use an existing partial evaluator for Scheme to implement template application. For example<br /><br /><br /><br /><center>Figure 1: Scheme translation</center><br /><div style="border: 1px solid ; padding: 2px;"><span style="font-family: courier new;"><br />Hello World! => (lambda () "Hello World!")<br /></span><span style="font-family: courier new;"><br />&lambda;x.Hello x => (lambda (x) (concat (lambda () "Hello") x))<br /></span><br /></div><br />Here 'concat' is some appropriately defined function that takes one or more templates and produces a new template (which is supposed to represent the concatenation of the input templates). 
